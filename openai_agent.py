import re
import csv

from openai import OpenAI
from datetime import datetime

class BookingAgent:
	"""
		A class representing a booking agent that manages appointments.

		Attributes:
			client (OpenAI): An instance of the OpenAI client.
			model_name (str): The name of the language model to use.
			bookings (list): A list of dictionaries representing the current bookings.

		Methods:
			__init__(self, api_key, model_name="gpt-4"): Initializes a new instance of the BookingAgent class.
			load_bookings(self, file_path): Loads bookings from a CSV file.
			add_booking(self, name, date, start, end): Adds a new booking to the list of bookings.
			is_available(self, name, date, start, end): Checks if a time slot is available for booking.
			receive_message(self, model, user_input): Receives a message from the language model.
			extract_entities(self, message): Extracts entities from a user input message.
			respond(self, user_input): Generates a response based on the user input.
		"""

	def __init__(self, api_key, model_name="gpt-4"):
		"""
		Initializes a new instance of the BookingAgent class.

		Args:
			api_key (str): The API key for the OpenAI client.
			model_name (str, optional): The name of the language model to use. Defaults to "gpt-4".
		"""
		self.client = OpenAI(
			api_key=api_key,
		)
		self.model_name = model_name
		self.bookings = self.load_bookings("appointments.csv")

	def load_bookings(self, file_path):
		"""
		Loads bookings from a CSV file.

		Args:
			file_path (str): The path to the CSV file.

		Returns:
			list: A list of dictionaries representing the bookings.
		"""
		bookings = []
		with open(file_path, mode='r') as file:
			reader = csv.DictReader(file)
			for row in reader:
				bookings.append(row)
		return bookings

	def add_booking(self, name, date, start, end):
		"""
		Adds a new booking to the list of bookings.

		Parameters:
			- name (str): The name of the booking.
			- date (str): The date of the booking.
			- start (str): The start time of the booking.
			- end (str): The end time of the booking.

		Returns:
			None
		"""
		new_booking = {"Name": name, "Date": date, "Start": start, "End": end}
		self.bookings.append(new_booking)
	
	def is_available(self, name, date, start, end):
		start_time = datetime.strptime(start, "%H:%M:%S").time()
		end_time = datetime.strptime(end, "%H:%M:%S").time()

		for booking in self.bookings:
			if booking['Name'] == name:
				if booking['Date'] == date:
					booked_start = datetime.strptime(booking['Start'], '%H:%M:%S').time()
					booked_end = datetime.strptime(booking['End'], '%H:%M:%S').time()
					if start_time < booked_end and end_time > booked_start:
						return True
		return False 

	def receive_message(self, model, user_input):
		"""
		Receives a user message and sends it to the OpenAI chat model for completion.

		Args:
			model (str): The name of the OpenAI chat model to use.
			user_input (str): The user's input message.

		Returns:
			str: The completed message generated by the chat model.
		"""
		chat_message = self.client.chat.completions.create(
			model=self.model_name,
			messages=[
				{
					"role": "user",
					"content": user_input,
				},
				{
					"role": "user",
					"content": "extract Name the Date, Start Time (%H:%M:%S format), End Time (%H:%M:%S format) from the user message.",
				}
			],
		)

		message = chat_message.choices[0].message.content
		return message

	def extract_entities(self, message):
		"""
		Extract information from the user input.
		Example message:
			user_input: I want to book an appointment with John Doe on July 20th, 2024 from 9 AM to 10 AM.
			extracted information: 
					Name: John Doe
					Date: July 20th, 2024
					Start Time: 09:00:00
					End Time: 10:00:00
		
		Args:
			message (str): The message containing the user input.
		
		Returns:
			tuple: A tuple containing the extracted entities (name, date, start_time, end_time).
		"""
		name = re.search(r"Name:\s*(.*)", message).group(1).strip()
		date = re.search(r"Date:\s*(.*)", message).group(1).strip()
		start_time = re.search(r"Start Time:\s*(.*)", message).group(1).strip()
		end_time = re.search(r"End Time:\s*(.*)", message).group(1).strip()

		print(f"Name: {name}, Date: {date}, Start: {start_time}, End: {end_time}")

		if name == None:
			name = ""
		if date == None:
			date = ""
		if start_time == None:
			start_time = ""
		if end_time == None:
			end_time = ""

		return name, date, end_time, end_time

	def respond(self, user_input):
			"""
			Responds to user input and performs availability checking or booking based on the input.

			Parameters:
			- user_input (str): The user's input message.

			Returns:
			- str: The response message based on the availability checking or booking.

			"""

			print(f"User input: {user_input}")
			message = self.receive_message(self.model_name, user_input)
			print(f"Received message: \n{message}")

			# Extract entities from the user input
			name, date, start, end = self.extract_entities(message)

			if date or start or end:
				available = self.is_available(name="Unknown", date=date, start=start, end=end)
				if available:
					return f"The time slot {date} from {start} to {end} is available."
				else:
					return f"The time slot {date} from {start} to {end} is not available."
			else:
				return "Please provide a date, start time, and end time for availability checking."

			if name or date or start or end:
				available = self.is_available(name=name, date=date, start=start, end=end)
				if self.is_available(date, start, end):
					self.add_booking(name, date, start, end)
					return f"Appointment booked for {name} on {date} from {start} to {end}."
				else:
					return f"Sorry, the time slot {date} from {start} to {end} is not available."
			else:
				return "Please provide a name, date, start time, and end time for booking."

			return response
